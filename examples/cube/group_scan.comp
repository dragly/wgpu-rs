#version 450

const uint LOCAL_SIZE = 512;

layout (local_size_x = LOCAL_SIZE, local_size_y = 1, local_size_z = 1) in;
//layout (local_size_x = 8, local_size_y = 1, local_size_z = 1) in;
//layout (local_size_x = 9, local_size_y = 1, local_size_z = 1) in;

struct DrawArguments {
    uint index_count;
    uint instance_count;
    uint base_index;
    int vertex_offset;
    uint base_instance;
};

struct DispatchArguments {
    uint x;
    uint y;
    uint z;
};

struct Instance {
    vec4 position;
    vec4 size;
    uint sector_id;
    uint sector_offset;
};

struct Sector {
    vec4 bbox_min;
    vec4 bbox_max;
    uint instance_count;
};

struct Visibility {
    uint visible;
    uint temp;
};

layout(set = 0, binding = 0) buffer PrimeIndices {
    DrawArguments[] indices;
}; // this is used as both input and output for convenience
layout(set = 0, binding = 1) buffer Instances {
    Instance[] instances;
};
layout(set = 0, binding = 2) buffer Visibilities {
    Visibility[] visibility;
};
layout(set = 0, binding = 3) buffer VisibleInstances {
    Instance[] visibleInstances;
};
layout(set = 0, binding = 4) buffer GroupSums {
    uint[] groupSums;
};
layout(set = 0, binding = 5) buffer Sectors {
    Sector[] sectors;
};
layout(set = 0, binding = 6) buffer DispatchArgumentss {
    DispatchArguments[] dispatchArguments;
}; 
layout(set = 0, binding = 7) buffer Debugs {
    uint[] debug;
}; 

layout(set = 1, binding = 0) uniform Locals {
    mat4 u_Transform;
};
layout(set = 1, binding = 1) uniform texture2D t_Color;
//layout(set = 1, binding = 1) uniform sampler2D t_Color;
layout(set = 1, binding = 2) uniform sampler s_Color;

shared uint temp[LOCAL_SIZE];

void main() {
    const uint global_group_count = groupSums.length();
    const uint global = gl_GlobalInvocationID.x;
    const uint local = gl_LocalInvocationID.x;
    const uint workGroup = gl_WorkGroupID.x;

    uint visibleInstanceCount = 0;

    if (global < global_group_count) {
        temp[local] = groupSums[global];
    } else {
        temp[local] = 0;
    }

    int o = 1;
    for (uint d = LOCAL_SIZE / 2; d > 0; d /= 2) {
        barrier();
        memoryBarrierShared();

        if (local < d) {
            int ai = o * (2 * int(local) + 1) - 1;
            int bi = o * (2 * int(local) + 2) - 1;
            temp[bi] += temp[ai];
        }
        o *= 2;
    }

    barrier();
    memoryBarrierShared();

    if (local == 0) {
        // After the first pass, the last element contains the instance count,
        // but we need to zero it out for the second pass.
        uint lastNumber = temp[LOCAL_SIZE - 1];
        visibleInstanceCount = lastNumber;
        temp[LOCAL_SIZE - 1] = 0;
    }

    for (int d = 1; d < LOCAL_SIZE; d *= 2) {
        barrier();
        memoryBarrierShared();
        o /= 2;
        if (local < d) {
            int ai = o * (2 * int(local) + 1) - 1;
            int bi = o * (2 * int(local) + 2) - 1;
            uint t = temp[ai];
            temp[ai] = temp[bi];
            temp[bi] += t;
        }
    }

    barrier();
    memoryBarrierShared();

    if (global < global_group_count) {
        groupSums[global] = temp[local];
        debug[local] = global;
    } else {
        debug[local] = 99;
    }

    if (global == 0) {
        indices[0].index_count = 36;
        //indices[0].instance_count = temp[instance_count - 1];
        indices[0].instance_count = visibleInstanceCount;
        //indices[0].instance_count = 0;
        //indices[0].instance_count = 8;
        indices[0].base_index = 0;
        indices[0].vertex_offset = 0;
        indices[0].base_instance = 0;

        dispatchArguments[0].x = visibleInstanceCount;
    }
}
